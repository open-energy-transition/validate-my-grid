meta {
	title: "Power QA";
	version: "0.11";
	description: "Validation ruleset for power features (power=*)";
	icon: "MapYourGrid-favicon.png";
	author: "nlehuby";
	link: "https://wiki.openstreetmap.org/wiki/Power_networks/Quality_Assurance";
	baselanguage: "en";
	-osmoseTags: list("tag", "power");
}

meta[lang=en] /* unused meta, only set so that tr() can catch string for translation */
{
	description: tr("Validation ruleset for power features (power=*)");
}
meta[lang=fr]
{
	description: "Règles de validation pour les réseaux électriques (power=*)";
}

way[disused:power=~/line|minor_line|cable/] > node[power=~/tower|pole|insulator|portal|terminal/],
way[construction:power=~/line|minor_line|cable/] > node[power=~/tower|pole|insulator|portal|terminal/],
way[power=~/line|minor_line|cable/] > node[power=~/tower|pole|insulator|portal|terminal/] {
	set .connected_ok_supports;
} 

node[power=~/tower|pole/]!.connected_ok_supports {
	throwWarning: tr("Lone power tower or pole. Try to connect it to a power=line");
}

node[power=~/insulator|portal/]!.connected_ok_supports {
	throwWarning: tr("Lone power portal or insulator. Try to connect it to a power=line");
}

node[power=~/terminal/]!.connected_ok_supports {
	throwWarning: tr("Lone power terminal. Try to connect it to a power=line");
}

way[disused:power=~/line|minor_line|cable/] >[index=-1] node[power],
way[construction:power=~/line|minor_line|cable/] >[index=1] node[power],
way[power=~/line|minor_line|cable/] >[index=-1] node[power],
way[power=~/line|minor_line|cable/] >[index=1] node[power] {
	set .end_of_power_lines;
} 

node.end_of_power_lines!:connection[power!~/^(transformer|generator|portal|terminal|insulator)$/][location:transition!=yes][substation!=minor_distribution][transformer!~/^(distribution|main)$/][line_management!~/^(transition|termination)$/] {
	throwWarning: tr("Unfinished power line");
}

node.end_of_power_lines:connection[count(parent_tags("voltage")) > 1][power!=transformer][!transformer] {
	throwWarning: tr("Connection between different voltages");
}

node.end_of_power_lines:connection[count(parent_tags("cables")) > 1][!line_management] {
	throwWarning: tr("Connection between different number of cables. Check the cables on incoming lines and the line_management tag on the intersecting tower");
}

node.end_of_power_lines[line_management][line_management=cross] {
	throwWarning: tr("A line_management=cross should not be at the end of a power line");
	fixRemove: "line_management";
}

node!.end_of_power_lines[power][line_management][line_management=split] {
	throwWarning: tr("line_management=split can only be at the end of a power line");
	fixRemove: "line_management";
}

node!.end_of_power_lines[power][line_management][line_management=termination] {
	throwWarning: tr("line_management=termination can only be at the end of a power line");
	fixRemove: "line_management";
}

node!.end_of_power_lines[power][line_management][line_management=transition] {
	throwWarning: tr("line_management=transition can only be at the end of a power line");
	fixRemove: "line_management";
}

area[power=substation] ∈ area[power=substation] {
	throwError: tr("Substation inside another substation");
}

*[power][power!~/^(cable|catenary_mast|circuit|compensator|connection|converter|generator|heliostat|insulator|inverter|line|line_section|minor_line|plant|pole|portal|substation|switch|switchgear|terminal|tower|transformer)$/] {
	throwError: tr("Unsuitable value for power=* tag");
	assertMatch: "relation power=route";
	assertMatch: "relation power=circuits";
	assertMatch: "relation power=cable_distribution_cabinet";
	assertNoMatch: "way power=cable";
}

way!:closed[power=substation],
relation[power=substation][type!=multipolygon] {
	throwError: tr("power=substation must be a node or an area");
	assertMatch: "relation power=substation type=power";
	assertNoMatch: "node power=substation";
}

way!:closed[power=generator],
relation[power=generator][type!=multipolygon] {
	throwError: tr("power=generator must be a node or an area");
	assertMatch: "relation power=generator type=power";
	assertMatch: "way power=generator";
	assertNoMatch: "node power=generator";
}

node[power=switchgear],
way!:closed[power=switchgear],
relation[power=switchgear][type!=multipolygon] {
	throwError: tr("power=switchgear must be an area");
	assertMatch: "relation power=switchgear";
	assertMatch: "node power=switchgear";
}

way!:closed[power=heliostat],
relation[power=heliostat][type!=multipolygon] {
	throwError: tr("power=heliostat must be a node or an area");
	assertMatch: "relation power=heliostat";
	assertNoMatch: "node power=heliostat";
}

way!:closed[power=plant],
relation[power=plant][type!=multipolygon][type!=site]{
	throwError: tr("power=plant must be an area or a site");
	assertMatch: "relation power=plant type=power";
	assertNoMatch: "relation power=plant type=multipolygon";
	assertNoMatch: "relation power=plant type=site";
}

node[power=cable],
area:closed[power=cable] {
	throwError: tr("power=cable must be a way");
	assertMatch: "node power=cable";
	assertNoMatch: "way power=cable";
}

node[power=minor_line],
area:closed[power=minor_line] {
	throwError: tr("power=minor_line must be a way");
	assertMatch: "node power=minor_line";
	assertNoMatch: "way power=minor_line";
}

way[power=line_section],
node[power=line_section],
area:closed[power=line_section] {
	throwError: tr("power=line_section must be a relation");
	assertMatch: "way power=line_section";
	assertNoMatch: "relation power=line_section type=power";
}

way[power=circuit],
node[power=circuit],
area:closed[power=circuit] {
	throwError: tr("power=circuit must be a relation");
	assertMatch: "way power=circuit";
	assertNoMatch: "relation power=circuit type=power";
}

area:closed[power=portal],
relation[power=portal] {
	throwError: tr("power=portal must be a node or an way");
	assertMatch: "relation power=portal";
	assertNoMatch: "way power=portal";
	assertNoMatch: "node power=portal";
}

area:closed[power=insulator],
relation[power=insulator] {
	throwError: tr("power=insulator must be a node or an way");
	assertMatch: "relation power=insulator";
	assertNoMatch: "way power=insulator";
	assertNoMatch: "node power=insulator";
}

way[power=~/line|minor_line|cable/][circuits][circuits =~ /(.*[A-Za-z].*)|.*,.*|.*( ).*/] {
	throwError: tr("circuits tag should contain a number");
	assertMatch: "way power=line circuits=double";
	assertNoMatch: "way power=line circuits=2";
	assertNoMatch: "way power=line circuits=1;1";
}

way[power=~/line|minor_line|cable/][cables][cables =~ /^[0-9]+(;[0-9]+)+$/] {
	throwWarning: tr("cables tag should be the sum of all cables");
	assertMatch: "way power=line cables=3;3";
	assertNoMatch: "way power=line cables=6";
}

way[power=~/line|minor_line|cable/][cables][cables !~ /^[0-9]+$/][cables !~ /^[0-9]+(;[0-9]+)+$/] {
    throwError: tr("cables tag should be a number");
    assertMatch: "way power=line cables=double";
    assertNoMatch: "way power=line cables=6";
    assertNoMatch: "way power=line cables=3;3";
}

way[power=~/line|minor_line|cable/][!voltage] {
    throwWarning: tr("Power lines should have a voltage tag");
    assertMatch: "way power=cable";
    assertNoMatch: "way power=cable voltage=500000";
}

node[power=transformer][!frequency] {
    throwWarning: tr("Transformers should have a frequency tag");
    assertMatch: "node power=transformer";
    assertNoMatch: "node power=transformer frequency=50";
}

*[power=substation][!substation] {
    throwWarning: tr("Substations should have a substation tag");
    assertMatch: "node power=substation";
    assertNoMatch: "node power=substation substation=transmission";
}

way[!power][!construction:power][!disused:power][!destroyed:power] > node[power=~/tower|pole|insulator|portal/] {
	throwError: tr("Power support connected to a non power feature");
}

node[power=~/tower|pole/] ∈ area[building] {
	throwError: tr("Power tower or pole inside a building");	
}


way[power=portal] > node {
	set .portal_nodes;
}

way[power=~/line|minor_line|cable/] >[index=-1] node,
way[power=~/line|minor_line|cable/] >[index=1] node {
	set .end_node_of_power_lines;
}

node.portal_nodes.end_node_of_power_lines[power!=insulator] {
	throwError: tr("A power line connecting to a portal should have a power=insulator on the connecting node");
	fixAdd: "power=insulator";
}

relation[type=power][!power] {
	throwError: tr("Is it a power circuit or a power line section? Add the power=* tag accordingly.");
	assertMatch: "relation type=power";
	assertNoMatch: "relation type=power power=circuit";
}

relation[power=circuit][topology][topology!~/^(linear|branched)$/] {
	throwError: tr("power=circuit relations should have a topology tag with value linear or branched");
	assertMatch: "relation type=power power=circuit topology=branch";
	assertNoMatch: "relation type=power power=circuit topology=branched";
	assertNoMatch: "relation type=power power=circuit";
}

*[power_source] {
	throwError: tr("power_source=* is deprecated");
	fixRemove: "power_source";
	suggestAlternative: "generator:source";
	assertMatch: "area power=plant power_source=solar";
	assertNoMatch: "area power=plant generator:source=solar";
}

relation[route=power] {
	throwError: tr("route=power is deprecated, use type=power+power=circuit instead");
	fixAdd: "type=power";
	fixAdd: "power=circuit";
	fixRemove: "route";
	assertMatch: "relation type=route route=power power=circuit";
	assertNoMatch: "relation type=power power=circuit";
}

relation[power=branch] {
	throwError: tr("power=branch is deprecated");
	suggestAlternative: "power=circuit or power=line_section";
	assertMatch: "relation type=power power=branch";
	assertNoMatch: "relation type=power power=circuit";
}

relation[power=circuit] >[role!~/^(section|substation)$/] way {  
   throwError: tr("Wrong role for way in power=circuit relations");
   suggestAlternative: "section/substation";
}

relation[power=circuit] >[role!~/^(tap|substation)$/] node {  
   throwError: tr("Wrong role for node in power=circuit relations");
   suggestAlternative: "tap/substation";
}

relation[power=circuit] >[role!~/^(section)$/] relation {  
   throwError: tr("Wrong role for node in power=circuit relations");
   suggestAlternative: "section";
}

relation[power=line_section] >[role!~/^(line)$/] way {  
   throwError: tr("Wrong role for way in power=line_section relations");
   suggestAlternative: "line";
}

relation[power=circuit] > way[power=~/^(line|minor_line|cable)$/][frequency] {  
   throwWarning: tr("frequency tag should be on the circuit relation, not on the power line");
}

relation[power=circuit][wires] {  
   throwWarning: tr("wires tag should be on the power line and not on the circuit relation");
   fixRemove: "wires";
   assertMatch: "relation type=power power=circuit wires=4";
   assertNoMatch: "relation type=power power=circuit";
}

node[power][line_management=termination][location:transition=yes]{
	throwWarning: tr("Incompatible tags: is it a line termination or a line transition ?");
	assertMatch: "node power=tower line_management=termination location:transition=yes";
	assertNoMatch: "node power=tower line_management=termination";
	assertNoMatch: "node power=tower line_management=transition location:transition=yes";
}

node[power=transformer][transformer=traction]{
	throwError: tr("transformer=traction is deprecated (use transformer=main and add substation=traction on the enclosing substation");
	fixAdd: "transformer=main";
	assertMatch: "node power=transformer transformer=traction";
	assertNoMatch: "node power=transformer transformer=main";
}

node[power=transformer][transformer=minor_distribution]{
	throwError: tr("transformer=minor_distribution is deprecated (use transformer=main and add substation=minor_distribution on the enclosing substation");
	fixAdd: "transformer=main";
	assertMatch: "node power=transformer transformer=minor_distribution";
	assertNoMatch: "node power=transformer transformer=main";
}

node[power=transformer][transformer=auto]{
	throwError: tr("transformer=auto is deprecated");
	fixAdd: "windings:auto=yes";
	fixRemove: "transformer";
	assertMatch: "node power=transformer transformer=auto";
	assertNoMatch: "node power=transformer transformer=main windings:auto=yes";
}

node[power=transformer][transformer][transformer!~/^(main|auxiliary|generator|converter|phase_angle_regulator|converter|distribution|yes|traction|minor_distribution|auto)$/] {
	throwError: tr("Unsuitable value for transformer=* tag");
	assertMatch: "node power=transformer transformer=railway";
	assertNoMatch: "node power=transformer transformer=main";
	assertNoMatch: "node power=transformer";
}

*[power=generator][generator:source][generator:source!~/^(nuclear|wind|hydro|tidal|wave|geothermal|solar|coal|gas|biomass|biofuel|biogas|oil|diesel|gasoline|waste|battery)(;(nuclear|wind|hydro|tidal|wave|geothermal|solar|coal|gas|biomass|biofuel|biogas|oil|diesel|gasoline|waste|battery))*$/] {
	throwError: tr("Unsuitable value for generator:source=* tag");
	assertMatch: "node power=generator generator:source=photovoltaic";
	assertMatch: "node power=generator generator:source=geothermals";
	assertNoMatch: "node power=generator generator:source=solar";
	assertNoMatch: "node power=generator generator:source=oil;gas";
	assertNoMatch: "node power=generator";
}

*[power=generator][generator:source=nuclear][generator:method][generator:method!~/^(fission|fusion)$/]{
	throwError: tr("Unsuitable method for nuclear generator");
	suggestAlternative: "fission or fusion";
	fixRemove: "generator:method";
	assertMatch: "node power=generator generator:source=nuclear generator:method=nuclear";
	assertNoMatch: "node power=generator generator:source=nuclear generator:method=fission";
}

*[power=generator][generator:method=~/fission|fusion/][generator:source][generator:source!=nuclear]{
	throwError: tr("Incompatibility between method and source on a power generator");
	assertMatch: "node power=generator generator:source=solar generator:method=fusion";
	assertNoMatch: "node power=generator generator:source=nuclear generator:method=fission";
}

*[power=generator][generator:source=wind][generator:method][generator:method!=wind_turbine]{
	throwError: tr("Unsuitable method for wind generator");
	fixRemove: "generator:method";
	assertMatch: "node power=generator generator:source=wind generator:method=wind";
	assertNoMatch: "node power=generator generator:source=wind";
	assertNoMatch: "node power=generator generator:source=wind generator:method=wind_turbine";
}

*[power=generator][generator:method=wind_turbine][generator:source][generator:source!=wind]{
	throwError: tr("Incompatibility between method and source on a power generator");
	assertMatch: "node power=generator generator:source=turbine generator:method=wind_turbine";
	assertNoMatch: "node power=generator generator:source=wind generator:method=wind_turbine";
}

*[power=generator][generator:source=hydro][generator:method][generator:method!~/^(water-storage|water-pumped-storage|run-of-the-river)$/]{
	throwError: tr("Unsuitable method for hydro generator");
	suggestAlternative: "water-storage, run-of-the-river or water-pumped-storage";
	fixRemove: "generator:method";
	assertMatch: "node power=generator generator:source=hydro generator:method=pump";
	assertNoMatch: "node power=generator generator:source=hydro generator:method=water-storage";
}

*[power=generator][generator:method=~/^(water-storage|water-pumped-storage|run-of-the-river)$/][generator:source][generator:source!=hydro]{
	throwError: tr("Incompatibility between method and source on a power generator");
	assertMatch: "node power=generator generator:source=water generator:method=water-pumped-storage";
	assertNoMatch: "node power=generator generator:source=hydro generator:method=water-storage";
}

*[power=generator][generator:source=tidal][generator:method][generator:method!~/^(barrage|stream)$/]{
	throwError: tr("Unsuitable method for tidal generator");
	suggestAlternative: "barrage or stream";
	fixRemove: "generator:method";
	assertMatch: "node power=generator generator:source=tidal generator:method=dam";
	assertNoMatch: "node power=generator generator:source=tidal generator:method=barrage";
}

*[power=generator][generator:method=~/^(barrage|stream)$/][generator:source][generator:source!=tidal]{
	throwError: tr("Incompatibility between method and source on a power generator");
	assertMatch: "node power=generator generator:source=solar generator:method=stream";
	assertNoMatch: "node power=generator generator:source=tidal generator:method=barrage";
}

*[power=generator][generator:source=solar][generator:method][generator:method!~/^(thermal|photovoltaic)$/]{
	throwError: tr("Unsuitable method for solar generator");
	suggestAlternative: "thermal or photovoltaic";
	fixRemove: "generator:method";
	assertMatch: "node power=generator generator:source=solar generator:method=solar";
	assertNoMatch: "node power=generator generator:source=solar generator:method=thermal";
}

*[power=generator][generator:method=~/^(thermal|photovoltaic)$/][generator:source][generator:source!=solar]{
	throwError: tr("Incompatibility between method and source on a power generator");
	assertMatch: "node power=generator generator:source=photovoltaic generator:method=photovoltaic";
	assertNoMatch: "node power=generator generator:source=solar generator:method=thermal";
}

*[power=generator][generator:source=coal][generator:method][generator:method!=combustion]{
	throwError: tr("Unsuitable method for coal generator");
	assertMatch: "node power=generator generator:source=coal generator:method=burning";
	assertNoMatch: "node power=generator generator:source=coal generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=coal";
}

*[power=generator][generator:source=gas][generator:method][generator:method!=combustion]{
	throwError: tr("Unsuitable method for gas generator");
	assertMatch: "node power=generator generator:source=gas generator:method=gasification";
	assertNoMatch: "node power=generator generator:source=gas generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=gas";
}

*[power=generator][generator:source=biomass][generator:method][generator:method!~/^(combustion|gasification|anaerobic_digestion)$/]{
	throwError: tr("Unsuitable method for biomass generator");
	suggestAlternative: "combustion, anaerobic_digestion or gasification";
	fixRemove: "generator:method";
	assertMatch: "node power=generator generator:source=biomass generator:method=burn";
	assertNoMatch: "node power=generator generator:source=biomass generator:method=anaerobic_digestion";
}

*[power=generator][generator:source=biofuel][generator:method][generator:method!=combustion]{
	throwError: tr("Unsuitable method for biofuel generator");
	assertMatch: "node power=generator generator:source=biofuel generator:method=gasification";
	assertNoMatch: "node power=generator generator:source=biofuel generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=biofuel";
}

*[power=generator][generator:source=biogas][generator:method][generator:method!=combustion]{
	throwError: tr("Unsuitable method for biogas generator");
	assertMatch: "node power=generator generator:source=biogas generator:method=gasification";
	assertNoMatch: "node power=generator generator:source=biogas generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=biogas";
}

*[power=generator][generator:source=oil][generator:method][generator:method!=combustion]{
	throwError: tr("Unsuitable method for oil generator");
	assertMatch: "node power=generator generator:source=oil generator:method=gasification";
	assertNoMatch: "node power=generator generator:source=oil generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=oil";
}

*[power=generator][generator:source=diesel][generator:method][generator:method!=combustion]{
	throwError: tr("Unsuitable method for diesel generator");
	assertMatch: "node power=generator generator:source=diesel generator:method=gasification";
	assertNoMatch: "node power=generator generator:source=diesel generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=diesel";
}

*[power=generator][generator:source=gasoline][generator:method][generator:method!=combustion]{
	throwError: tr("Unsuitable method for gasoline generator");
	assertMatch: "node power=generator generator:source=gasoline generator:method=gasification";
	assertNoMatch: "node power=generator generator:source=gasoline generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=gasoline";
}

*[power=generator][generator:source=waste][generator:method][generator:method!~/^(combustion|gasification)$/]{
	throwError: tr("Unsuitable method for waste generator");
	suggestAlternative: "combustion or gasification";
	fixRemove: "generator:method";
	assertMatch: "node power=generator generator:source=waste generator:method=burning";
	assertNoMatch: "node power=generator generator:source=waste generator:method=combustion";
}

*[power=generator][generator:method=combustion][generator:source][generator:source!~/^(waste|gasoline|diesel|oil|biogas|biofuel|biomass|gas|coal)(;(waste|gasoline|diesel|oil|biogas|biofuel|biomass|gas|coal))*$/]{
	throwError: tr("Incompatibility between method and source on a power generator");
	assertMatch: "node power=generator generator:source=wave generator:method=combustion";
	assertMatch: "node power=generator generator:source=waste;solar generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=biomass generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=gas;oil generator:method=combustion";
	assertNoMatch: "node power=generator generator:source=gas;oil;waste generator:method=combustion";

}

*[power=generator][generator:method=gasification][generator:source][generator:source!~/^(waste|biomass)(;(waste|biomass))*$/]{
	throwError: tr("Incompatibility between method and source on a power generator");
	assertMatch: "node power=generator generator:source=coal generator:method=gasification";
	assertNoMatch: "node power=generator generator:source=biomass generator:method=gasification";
	assertNoMatch: "node power=generator generator:source=biomass;waste generator:method=gasification";
}


*[power=plant][plant:source][plant:source!~/^(nuclear|wind|hydro|tidal|wave|geothermal|solar|coal|gas|biomass|biofuel|biogas|oil|diesel|gasoline|waste|battery)(;(nuclear|wind|hydro|tidal|wave|geothermal|solar|coal|gas|biomass|biofuel|biogas|oil|diesel|gasoline|waste|battery))*$/] {
	throwError: tr("Unsuitable value for plant:source=* tag");
	assertMatch: "node power=plant plant:source=photovoltaic";
	assertNoMatch: "node power=plant plant:source=solar";
	assertNoMatch: "node power=plant plant:source=gas;oil";
	assertNoMatch: "node power=plant";
}

*[power=plant][plant:source=nuclear][plant:method][plant:method!~/^(fission|fusion)$/]{
	throwError: tr("Unsuitable method for nuclear power plant");
	suggestAlternative: "fission or fusion";
	fixRemove: "plant:method";
	assertMatch: "node power=plant plant:source=nuclear plant:method=nuclear";
	assertNoMatch: "node power=plant plant:source=nuclear plant:method=fission";
}

*[power=plant][plant:method=~/^(fission|fusion)$/][plant:source][plant:source!=nuclear]{
	throwError: tr("Incompatibility between method and source on a power plant");
	assertMatch: "node power=plant plant:source=solar plant:method=fusion";
	assertNoMatch: "node power=plant plant:source=nuclear plant:method=fission";
}

*[power=plant][plant:source=wind][plant:method][plant:method!=wind_turbine]{
	throwError: tr("Unsuitable method for wind power plant");
	fixRemove: "plant:method";
	assertMatch: "node power=plant plant:source=wind plant:method=wind";
	assertNoMatch: "node power=plant plant:source=wind";
	assertNoMatch: "node power=plant plant:source=wind plant:method=wind_turbine";
}

*[power=plant][plant:method=wind_turbine][plant:source][plant:source!=wind]{
	throwError: tr("Incompatibility between method and source on a power plant");
	assertMatch: "node power=plant plant:source=eolien plant:method=wind_turbine";
	assertNoMatch: "node power=plant plant:source=wind plant:method=wind_turbine";
}

*[power=plant][plant:source=hydro][plant:method][plant:method!~/^(water-storage|water-pumped-storage|run-of-the-river)$/]{
	throwError: tr("Unsuitable method for hydro power plant");
	suggestAlternative: "water-storage, run-of-the-river or water-pumped-storage";
	fixRemove: "plant:method";
	assertMatch: "node power=plant plant:source=hydro plant:method=pump";
	assertNoMatch: "node power=plant plant:source=hydro plant:method=water-storage";
}

*[power=plant][plant:method=~/^(water-storage|water-pumped-storage|run-of-the-river)$/][plant:source][plant:source!=hydro]{
	throwError: tr("Incompatibility between method and source on a power plant");
	assertMatch: "node power=plant plant:source=water plant:method=water-pumped-storage";
	assertNoMatch: "node power=plant plant:source=hydro plant:method=water-storage";
}

*[power=plant][plant:source=tidal][plant:method][plant:method!~/^(barrage|stream)$/]{
	throwError: tr("Unsuitable method for tidal power plant");
	suggestAlternative: "barrage or stream";
	fixRemove: "plant:method";
	assertMatch: "node power=plant plant:source=tidal plant:method=dam";
	assertNoMatch: "node power=plant plant:source=tidal plant:method=barrage";
}

*[power=plant][plant:method=~/^(barrage|stream)$/][plant:source][plant:source!=tidal]{
	throwError: tr("Incompatibility between method and source on a power plant");
	assertMatch: "node power=plant plant:source=solar plant:method=stream";
	assertNoMatch: "node power=plant plant:source=tidal plant:method=barrage";
}

*[power=plant][plant:source=solar][plant:method][plant:method!~/^(thermal|photovoltaic)$/]{
	throwError: tr("Unsuitable method for solar power plant");
	suggestAlternative: "thermal or photovoltaic";
	fixRemove: "plant:method";
	assertMatch: "node power=plant plant:source=solar plant:method=solar";
	assertNoMatch: "node power=plant plant:source=solar plant:method=thermal";
}

*[power=plant][plant:method=~/^(thermal|photovoltaic)$/][plant:source][plant:source!=solar]{
	throwError: tr("Incompatibility between method and source on a power plant");
	assertMatch: "node power=plant plant:source=photovoltaic plant:method=photovoltaic";
	assertNoMatch: "node power=plant plant:source=solar plant:method=thermal";
}

*[power=plant][plant:source=coal][plant:method][plant:method!=combustion]{
	throwError: tr("Unsuitable method for coal power plant");
	assertMatch: "node power=plant plant:source=coal plant:method=burning";
	assertNoMatch: "node power=plant plant:source=coal plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=coal";
}

*[power=plant][plant:source=gas][plant:method][plant:method!=combustion]{
	throwError: tr("Unsuitable method for gas power plant");
	assertMatch: "node power=plant plant:source=gas plant:method=gasification";
	assertNoMatch: "node power=plant plant:source=gas plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=gas";
}

*[power=plant][plant:source=biomass][plant:method][plant:method!~/^(combustion|gasification|anaerobic_digestion)$/]{
	throwError: tr("Unsuitable method for biomass power plant");
	suggestAlternative: "combustion, anaerobic_digestion or gasification";
	fixRemove: "plant:method";
	assertMatch: "node power=plant plant:source=biomass plant:method=burn";
	assertNoMatch: "node power=plant plant:source=biomass plant:method=anaerobic_digestion";
}

*[power=plant][plant:source=biofuel][plant:method][plant:method!=combustion]{
	throwError: tr("Unsuitable method for biofuel power plant");
	assertMatch: "node power=plant plant:source=biofuel plant:method=gasification";
	assertNoMatch: "node power=plant plant:source=biofuel plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=biofuel";
}

*[power=plant][plant:source=biogas][plant:method][plant:method!=combustion]{
	throwError: tr("Unsuitable method for biogas power plant");
	assertMatch: "node power=plant plant:source=biogas plant:method=gasification";
	assertNoMatch: "node power=plant plant:source=biogas plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=biogas";
}

*[power=plant][plant:source=oil][plant:method][plant:method!=combustion]{
	throwError: tr("Unsuitable method for oil power plant");
	assertMatch: "node power=plant plant:source=oil plant:method=gasification";
	assertNoMatch: "node power=plant plant:source=oil plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=oil";
}

*[power=plant][plant:source=diesel][plant:method][plant:method!=combustion]{
	throwError: tr("Unsuitable method for diesel power plant");
	assertMatch: "node power=plant plant:source=diesel plant:method=gasification";
	assertNoMatch: "node power=plant plant:source=diesel plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=diesel";
}

*[power=plant][plant:source=gasoline][plant:method][plant:method!=combustion]{
	throwError: tr("Unsuitable method for gasoline power plant");
	assertMatch: "node power=plant plant:source=gasoline plant:method=gasification";
	assertNoMatch: "node power=plant plant:source=gasoline plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=gasoline";
}

*[power=plant][plant:source=waste][plant:method][plant:method!~/^(combustion|gasification)$/]{
	throwError: tr("Unsuitable method for waste power plant");
	suggestAlternative: "combustion or gasification";
	fixRemove: "plant:method";
	assertMatch: "node power=plant plant:source=waste plant:method=burning";
	assertNoMatch: "node power=plant plant:source=waste plant:method=combustion";
}

*[power=plant][plant:method=combustion][plant:source][plant:source!~/^(waste|gasoline|diesel|oil|biogas|biofuel|biomass|gas|coal)(;(waste|gasoline|diesel|oil|biogas|biofuel|biomass|gas|coal))*$/]{
	throwError: tr("Incompatibility between method and source on a power plant");
	assertMatch: "node power=plant plant:source=wave plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=biomass plant:method=combustion";
	assertNoMatch: "node power=plant plant:source=biomass;waste plant:method=combustion";
}

*[power=plant][plant:method=gasification][plant:source][plant:source!~/^(waste|biomass)(;(waste|biomass))*$/]{
	throwError: tr("Incompatibility between method and source on a power plant");
	assertMatch: "node power=plant plant:source=coal plant:method=gasification";
	assertNoMatch: "node power=plant plant:source=biomass plant:method=gasification";
	assertNoMatch: "node power=plant plant:source=biomass;waste plant:method=gasification";
}
