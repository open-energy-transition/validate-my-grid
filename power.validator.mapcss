meta {
	title: "Power QA";
	version: "0.4";
	description: "Validation ruleset for power features (power=*)";
	icon: "MapYourGrid-favicon.png";
	author: "nlehuby";
	link: "https://wiki.openstreetmap.org/wiki/Power_networks/Quality_Assurance";
	baselanguage: "en";
	-osmoseTags: list("tag", "power");
}

meta[lang=en] /* unused meta, only set so that tr() can catch string for translation */
{
	description: tr("Validation ruleset for power features (power=*)");
}
meta[lang=fr]
{
	description: "Règles de validation pour les réseaux électriques (power=*)";
}


way[power=~/line|minor_line|cable/] > node[power=~/tower|pole|insulator|portal|terminal/] {
	set .connected_ok_supports;
} 

node[power=~/tower|pole/]!.connected_ok_supports {
	throwWarning: tr("Lone power tower or pole. Try to connect it to a power=line");
}

node[power=~/insulator|portal/]!.connected_ok_supports {
	throwWarning: tr("Lone power portal or insulator. Try to connect it to a power=line");
}

node[power=~/terminal/]!.connected_ok_supports {
	throwWarning: tr("Lone power terminal. Try to connect it to a power=line");
}


way[power=~/line|minor_line|cable/] >[index=-1] node[power],
way[power=~/line|minor_line|cable/] >[index=1] node[power] {
	set .end_of_power_lines;
} 

node.end_of_power_lines!:connection[power!~/transformer|generator|portal|terminal|insulator/][location:transition!=yes][substation!=minor_distribution][transformer!~/distribution|main/][line_management!~/transition|termination/] {
	throwWarning: tr("Unfinished power line");
}

node.end_of_power_lines:connection[count(parent_tags("voltage")) > 1][power!=transformer][!transformer] {
	throwWarning: tr("Connection between different voltages");
}

node.end_of_power_lines:connection[count(parent_tags("cables")) > 1][line_management!=split] {
	throwWarning: tr("Connection between different number of cables. Check the cables on incoming lines and the line_management tag on the intersecting tower");
}

area[power=substation] ∈ area[power=substation] {
	throwError: tr("Substation inside another substation");
}

/* does not work, not sure why ... */
/*
way[power=portal] ∈ area[power=substation],
node[power=portal] ∈ area[power=substation] {
	set .portal_in_substation;
}

node[power=portal]!.portal_in_substation {
	throwError: tr("Power portal outside substation");	
}
*/

*[power][power!~/cable|catenary_mast|circuit|compensator|connection|converter|generator|heliostat|insulator|inverter|line|line_section|minor_line|plant|pole|portal|substation|switch|switchgear|terminal|tower|transformer/] {
	throwError: tr("Unsuitable value for power=* tag");
	assertMatch: "relation power=route";
	assertNoMatch: "way power=cable";
}

way!:closed[power=substation],
relation[power=substation][type!=multipolygon] {
	throwError: tr("power=substation must be a node or an area");
	assertMatch: "relation power=substation type=power";
	assertNoMatch: "node power=substation";
}

node[power=cable],
area:closed[power=cable] {
	throwError: tr("power=cable must be a way");
	assertMatch: "node power=cable";
	assertNoMatch: "way power=cable";
}

node[power=minor_line],
area:closed[power=minor_line] {
	throwError: tr("power=minor_line must be a way");
	assertMatch: "node power=minor_line";
	assertNoMatch: "way power=minor_line";
}

way[power=line_section],
node[power=line_section],
area:closed[power=line_section] {
	throwError: tr("power=line_section must be a relation");
	assertMatch: "way power=line_section";
	assertNoMatch: "relation power=line_section type=power";
}

way[power=circuit],
node[power=circuit],
area:closed[power=circuit] {
	throwError: tr("power=circuit must be a relation");
	assertMatch: "way power=circuit";
	assertNoMatch: "relation power=circuit type=power";
}

area:closed[power=portal],
relation[power=portal] {
	throwError: tr("power=portal must be a node or an way");
	assertMatch: "relation power=portal";
	assertNoMatch: "way power=portal";
	assertNoMatch: "node power=portal";
}

area:closed[power=insulator],
relation[power=insulator] {
	throwError: tr("power=insulator must be a node or an way");
	assertMatch: "relation power=insulator";
	assertNoMatch: "way power=insulator";
	assertNoMatch: "node power=insulator";
}

way[power=~/line|minor_line|cable/][circuits][circuits !~ /^[0-9]+$/] {
	throwError: tr("circuits tag should contain a number");
	assertMatch: "way power=line circuits=double";
	assertNoMatch: "way power=line circuits=2";
}

way[power=~/line|minor_line|cable/][cables][cables !~ /^[0-9]+$/] {
	throwError: tr("cables tag should contain a number");
	assertMatch: "way power=line cables=double";
	assertNoMatch: "way power=line cables=6";
}

node[power=transformer][!frequency] {
    throwWarning: tr("Transformers should have a frequency tag");
    assertMatch: "node power=transformer";
    assertNoMatch: "node power=transformer frequency=50";
}

way[!power][!construction:power][!disused:power][!destroyed:power] > node[power=~/tower|pole|insulator|portal/] {
	throwError: tr("Power support connected to a non power feature");
}

node[power=~/tower|pole/] ∈ area[building] {
	throwError: tr("Power tower or pole inside a building");	
}


way[power=portal] > node {
	set .portal_nodes;
}

way[power=~/line|minor_line|cable/] >[index=-1] node,
way[power=~/line|minor_line|cable/] >[index=1] node {
	set .end_node_of_power_lines;
}

node.portal_nodes.end_node_of_power_lines[power!=insulator] {
	throwError: tr("A power line connecting to a portal should have a power=insulator on the connecting node");
	fixAdd: "power=insulator";
}

relation[type=power][!power] {
	throwError: tr("Is it a power circuit or a power line section? Add the power=* tag accordingly.");
	assertMatch: "relation type=power";
	assertNoMatch: "relation type=power power=circuit";
}

relation[power=circuit][topology][topology!~/linear|branched/] {
	throwError: tr("power=circuit relations should have a topology tag with value linear or branched");
	assertMatch: "relation type=power power=circuit topology=branch";
	assertNoMatch: "relation type=power power=circuit topology=branched";
	assertNoMatch: "relation type=power power=circuit";
}

relation[route=power] {
	throwError: tr("route=power is deprecated, use type=power+power=circuit instead");
	fixAdd: "type=power";
	fixAdd: "power=circuit";
	fixRemove: "route";
	assertMatch: "relation type=route route=power power=circuit";
	assertNoMatch: "relation type=power power=circuit";
}

relation[power=branch] {
	throwError: tr("power=branch is deprecated");
	suggestAlternative: "power=circuit or power=line_section";
	assertMatch: "relation type=power power=branch";
	assertNoMatch: "relation type=power power=circuit";
}

relation[power=circuit] >[role!~/section|substation/] way {  
   throwError: tr("Wrong role for way in power=circuit relations");
   suggestAlternative: "section/substation";
}

relation[power=circuit] >[role!~/tap|substation/] node {  
   throwError: tr("Wrong role for node in power=circuit relations");
   suggestAlternative: "tap/substation";
}

relation[power=circuit] >[role!~/section/] relation {  
   throwError: tr("Wrong role for node in power=circuit relations");
   suggestAlternative: "section";
}

relation[power=line_section] >[role!~/line/] way {  
   throwError: tr("Wrong role for way in power=line_section relations");
   suggestAlternative: "line";
}

relation[power=circuit] > way[power=~/line|minor_line|cable/][frequency] {  
   throwWarning: tr("frequency tag should be on the circuit relation, not on the power line");
}

relation[power=circuit][wires] {  
   throwWarning: tr("wires tag should be on the power line and not on the circuit relation");
   fixRemove: "wires";
   assertMatch: "relation type=power power=circuit wires=4";
   assertNoMatch: "relation type=power power=circuit";

}